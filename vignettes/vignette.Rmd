---
title: "Introdunction to `BMsimulation` R package"
output: 
  html_document:
    number_sections: true
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
  pdf_document:
    number_sections: true
    toc: TRUE
    toc_depth: 3
    citation_package: natbib
bibliography: ref.bib
# biblio-style: apalike
vignette: >
  %\VignetteIndexEntry{Introdunction to `BMsimulation` R package}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72 
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

In this document, we illustrate the main features of the `BMsimulation` R package through examples. The main goal of this package is to perform simulation study to assess the Bayesian Melding model when grid cell varies. 

# Introduction to Bayesian Melding model 

The Bayesian Melding model is applied in spatial statistic. It melds the output from the deterministic simulating model with
the point-referenced data from the monitoring locations using a hierarchical Bayesian framework.

## Installation 

Install the package from Github. 

```{r,eval=FALSE}
devtools::install_github('YuxuanZhao1/BMsimulation')
```

Load the package.

```{r}
library(BMsimulation)
```
## Basic examples about data simulation

### Simulate the locations 

We can use the function `simudata_data_position` to simulate the 20 monitoring and 100 unmonitored locations and 2 grid cells within the coordinates $[-5,5]\times [-5,5]$ and one sampling point within each gird cell under the random seed 1234. 

```{r,eval=FALSE}
simudata_data_position(m1 = 20, m2 = 2, n.pred = 100 , ran = 5, nm = 1, seed = 1234)
```
The arguments will take:

* `m1`: Number of monitoring locations
* `m2`: Number of grid cells
* `n.pred`: Number of unmonitored locations for prediction
* `ran`: Range for the monitoring/unmonitored locations and sampling points within grid cells
* `nm`: 	Number of points within each of grid cells
* `seed`:	Random seed number


### Simulate the realizations at the position 

We can use the function `simudata_data` to simulate realizations at locations of monitoring/unmonitored stations and within grid cells to construct 500 independent data sets.

The function will take the same arguments as `simudata_data_position` with one additional argument `nhours`, which represents the number of independent data sets during simulation studies. 

```{r,eval=FALSE}
simudata_data(m1 = 20, m2 = 2, n.pred = 100 , ran = 5, nm = 1, nhours = 500, seed = 1234)
```


##  Basic example about replcating the simulation

### Rerun the simulation

We can use the following code to replicate our simulation studies. It allows for parallel computing and takes about half an hour to run the most complicated case with grid cell equal 50 on a 80-core machine. 

The arguments will take:

* `m1`: Number of monitoring locations
* `m2`: Number of grid cells
* `n.pred`: Number of unmonitored locations for prediction
* `ran`: Range for the monitoring/unmonitored locations and sampling points within grid cells
* `nm`: 	Number of points within each of grid cells
* `nhours`: Number of independent data sets
* `ton`: Number of MCMC iterations in the Gibbs sampling
* `burnin`: The “burn-in” period of the Gibbs sampling
* `degree`: Degree of the polynomial function
* `nbeta`: Length of regression coefficient vector
* `ntheta`: Length of covariance parameter vector
* `nab`: Length of calibration parameter vector
* `nerror`: Length of error vector
* `cov.model`: Type of covariance function
* `seed`:	Random seed number
* `num_for_cores`: Number of cores for parallel computing

```{r, eval = FALSE}
resu_expo_2 = run_func(m1=20, m2=2, n.pred = 100, ran = 5, nm = 1, nhours = 500,
                        ton = 10000, burnin = 5000, degree = 1, nbeta= 3,  ntheta= 2, nab=2, nerror=2,
                        cov.model = "exponential", seed = 1234, num_for_cores = 80)

resu_expo_10 = run_func(m1=20, m2=10, n.pred = 100, ran = 5, nm = 1, nhours = 500,
         ton = 10000, burnin = 5000, degree = 1, nbeta= 3,  ntheta= 2, nab=2, nerror=2,
         cov.model = "exponential", seed = 1234, num_for_cores = 80)

resu_expo_20 = run_func(m1=20, m2=20, n.pred = 100, ran = 5, nm = 1, nhours = 500,
                        ton = 10000, burnin = 5000, degree = 1, nbeta= 3,  ntheta= 2, nab=2, nerror=2,
                        cov.model = "exponential", seed = 1234, num_for_cores = 80)

resu_expo_30 = run_func(m1=20, m2=30, n.pred = 100, ran = 5, nm = 1, nhours = 500,
                        ton = 10000, burnin = 5000, degree = 1, nbeta= 3,  ntheta= 2, nab=2, nerror=2,
                        cov.model = "exponential", seed = 1234, num_for_cores = 80)

resu_expo_50 = run_func(m1=20, m2=50, n.pred = 100, ran = 5, nm = 1, nhours = 500,
                        ton = 10000, burnin = 5000, degree = 1, nbeta= 3,  ntheta= 2, nab=2, nerror=2,
                        cov.model = "exponential", seed = 1234, num_for_cores = 80)
```

We simply load the results to avoid from knitting the file for a long time.

```{r}
load("running_results.RData")
```

## Basic example about summmarizing and visualizing the results

### Generate the traceplot

We generate the traceplots of the unknown model parameters for the case with 50 grid cells within 10,000 MCMC iterations using the 30-th data set. 

The arguments to take:
* `result`: The first element from the output of the `run_func` function
* `num_data_set`: The number of independent during simulation, take the number from 1 to nhours

```{r}
traceplot_plt(resu_expo_50, 30)
```




### Combing results from different cases with varying number of gird cells

We can use this function to combine the results from different cases. 

The arguments will take:

* `resu_1`: The first element from the output of the melding function when we consider 2 grid cells
* `resu_2`: The first element from the output of the melding function when we consider 10 grid cells
* `resu_3`: The first element from the output of the melding function when we consider 20 grid cells
* `resu_4`: The first element from the output of the melding function when we consider 30 grid cells
* `resu_5`: The first element from the output of the melding function when we consider 50 grid cells
* `nhours`:	Number of independent data sets
* `n.pred`: Number of unmonitored locations
* `nbeta`: Length of regression coefficient vector
* `ntheta`: Length of covariance parameter vector
* `nab`: Length of calibration parameter vector

```{r}
res = compute_param_error(resu_1 = resu_expo_2,
                          resu_2 = resu_expo_10,
                          resu_3 = resu_expo_20,
                          resu_4 = resu_expo_30,
                          resu_5 = resu_expo_50,
                          nhours = 500,n.pred = 100,nbeta = 3, ntheta = 2, nab = 2)
```

### Summarize the results

We can generate the table summary of average mean squared prediction error and Monte Carlo Standard Error.

The arguments will take: 

* `nhours`:	Number of simulation times
* `errorvec_1`:	The error vector from output of `compute_param_error` function with grid cell = 2
* `errorvec_2`:	The error vector from output of `compute_param_error` function with grid cell = 10
* `errorvec_3`:	The error vector from output of `compute_param_error` function with grid cell = 20
* `errorvec_4`:	The error vector from output of `compute_param_error` function with grid cell = 30
* `errorvec_5`:	The error vector from output of `compute_param_error` function with grid cell = 50
* `n.pred`: Number of unmonitored locations

```{r}
knitr::kable(mspe_tab(nhours = 500, errorvec_1 = res$error_2,
                    errorvec_2 = res$error_10,
                    errorvec_3 = res$error_20,
                    errorvec_4 = res$error_30,
                    errorvec_5 = res$error_50, n.pred = 100), digits = 4,"markdown")
```

We can generate the plot to show the changing pattern of average mean squared prediction error. 

This function takes the same arugment as `mspe_tab` function.
```{r}
mspe_plt(nhours = 500, errorvec_1 = res$error_2,
                    errorvec_2 = res$error_10,
                    errorvec_3 = res$error_20,
                    errorvec_4 = res$error_30,
                    errorvec_5 = res$error_50, n.pred = 100)
```

We can also plot the positions of monitored/unmonitored sites and sampling points within 2 grid cell. 

The function only accepts the output from `run_func` with grid cell = 2. 

```{r}
point_plt(resu_expo_2)
```
